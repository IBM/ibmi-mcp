---
title: "Writing YAML SQL Tools"
description: "Step-by-step guide to creating custom SQL tools using YAML configuration with real IBM i system examples from the prebuilt configurations."
---

# Writing YAML SQL Tools

YAML SQL tools provide a powerful way to create reusable, parameterized database operations without writing custom code. This guide walks through the complete process of designing, implementing, and deploying YAML-based SQL tools using real examples from the IBM i MCP Server's prebuilt configurations.

<Info>
YAML tools offer the perfect balance between the flexibility of dynamic SQL and the structure of custom TypeScript tools. The prebuilt configurations demonstrate production-ready patterns you can adapt for your own needs.
</Info>

## Why Choose YAML Tools?

<CardGroup cols={2}>
  <Card title="Developer Productivity" icon="rocket">
    **Fast Development Cycle**
    
    - No compilation required
    - Hot-reload configuration changes  
    - Immediate testing and iteration
    - Visual parameter validation
  </Card>
  
  <Card title="Enterprise Features" icon="shield-check">
    **Production-Ready Capabilities**
    
    - Built-in parameter validation
    - Automatic SQL injection protection
    - Connection pool optimization  
    - Comprehensive error handling
  </Card>
</CardGroup>

## Real YAML Tool Examples

Let's examine actual production tools from the prebuilt configurations to understand the patterns:

<Tabs>
<Tab title="System Performance Tools">
**From prebuiltconfigs/performance.yaml**

```yaml
sources:
  ibmi-system:
    host: ${DB2i_HOST}
    user: ${DB2i_USER}
    password: ${DB2i_PASS}
    port: 8076
    ignore-unauthorized: true

tools:
  system_status:
    source: ibmi-system
    description: "Overall system performance statistics with CPU, memory, and I/O metrics"
    parameters: []
    statement: |
      SELECT * FROM TABLE(QSYS2.SYSTEM_STATUS(RESET_STATISTICS=>'YES',DETAILED_INFO=>'ALL')) X

  active_job_info:
    source: ibmi-system
    description: "Find the top CPU consumers in QUSRWRK and QSYSWRK subsystems"
    parameters:
      - name: limit
        type: integer
        default: 10
        description: "Number of top CPU consumers to return"
    statement: |
      SELECT CPU_TIME, A.* FROM 
      TABLE(QSYS2.ACTIVE_JOB_INFO(SUBSYSTEM_LIST_FILTER => 'QUSRWRK,QSYSWRK')) A 
      ORDER BY CPU_TIME DESC 
      FETCH FIRST :limit ROWS ONLY

toolsets:
  performance:
    tools:
      - system_status
      - system_activity
      - memory_pools
      - active_job_info
```
</Tab>

<Tab title="System Administration Tools">
**From prebuiltconfigs/sys-admin.yaml**

```yaml
tools:
  describe_object:
    source: ibmi-system
    description: "Describe an SQL object by generating DDL definition"
    statement: |
      CALL QSYS2.GENERATE_SQL(
          DATABASE_OBJECT_NAME => :name,
          DATABASE_OBJECT_LIBRARY_NAME => :library,
          DATABASE_OBJECT_TYPE => :type,
          CREATE_OR_REPLACE_OPTION => '1',
          PRIVILEGES_OPTION => '0',
          STATEMENT_FORMATTING_OPTION => '0',
          SOURCE_STREAM_FILE_END_OF_LINE => 'LF',
          SOURCE_STREAM_FILE_CCSID => 1208
      )
    parameters:
      - name: name
        type: string
        description: "The name of the object"
        required: true
      - name: library
        type: string
        description: "The name of the library where the object is defined"
        required: true
        default: QSYS2
      - name: type
        type: string
        default: TABLE
        description: "Object type: TABLE, VIEW, PROCEDURE, FUNCTION, etc."

  search_services_by_name:
    source: ibmi-system
    description: "Case-insensitive search of services by name (contains match)"
    statement: |
      SELECT service_category,
             service_schema_name,
             service_name,
             sql_object_type,
             earliest_possible_release
      FROM qsys2.services_info
      WHERE UPPER(service_name) LIKE UPPER('%' CONCAT :name_contains CONCAT '%')
      ORDER BY service_category, service_schema_name, service_name
    parameters:
      - name: name_contains
        type: string
        description: "Substring to search for in SERVICE_NAME"
        required: true
        minLength: 2

toolsets:
  sysadmin_discovery:
    title: "Sys Admin Discovery"
    description: "High-level summaries and counts for services"
    tools:
      - list_service_categories
      - count_services_by_schema
      - count_services_by_sql_object_type
      
  sysadmin_search:
    title: "Sys Admin Search"
    description: "Search capabilities for service names and example usage"
    tools:
      - search_services_by_name
      - where_is_service
      - search_examples_for_keyword
```
</Tab>

<Tab title="Advanced Features">
**Security and Metadata**

```yaml
tools:
  execute_sql:
    source: ibmi-system
    description: "Execute arbitrary SQL statements"
    parameters:
      - name: sql
        type: string
        description: "The SQL statement to execute"
    statement: |
      :sql
    security:
      readOnly: true
      maxQueryLength: 15000
      forbiddenKeywords: ["TRUNCATE", "FORMAT", "DELETE", "UPDATE", "DROP"]
    domain: sysadmin
    category: discovery
    metadata:
      title: "Dynamic SQL Execution"
```
</Tab>
</Tabs>

## Step 1: Planning Your Tool

Before writing YAML, design your tool by answering these questions:

### Define the Business Need

<Steps>
<Step title="Identify the Use Case">
What specific business problem does this tool solve?

**Example**: "Sales team needs quick customer lookup by ID or email for support calls"
</Step>

<Step title="Define Expected Inputs">
What parameters will users provide?

**Example**: 
- Customer ID (optional, integer)
- Email address (optional, string)
- Include inactive customers (optional, boolean, default false)
</Step>

<Step title="Design the Output">
What data should the tool return?

**Example**: Customer profile with ID, name, email, phone, status, and last order date
</Step>

<Step title="Consider Edge Cases">
How should the tool handle invalid inputs or empty results?

**Example**: Return empty results for non-existent customers, validate email format
</Step>
</Steps>

## Step 2: Creating Your First Tool

Let's build a comprehensive customer lookup tool step by step.

### Define the Database Source

Create your YAML configuration file (e.g., `customer-tools.yaml`):

```yaml
sources:
  crm-database:
    host: ${CRM_DB_HOST}
    user: ${CRM_DB_USER}  
    password: ${CRM_DB_PASSWORD}
    port: 8076
    ignore-unauthorized: ${CRM_DB_IGNORE_UNAUTHORIZED:false}
    options:
      naming: "sql"
      date-format: "iso"
```

<Note>
Use environment variables for sensitive information like credentials. The `${VAR:default}` syntax provides fallback values.
</Note>

### Build the Core Tool

```yaml
tools:
  customer_lookup:
    source: crm-database
    description: "Comprehensive customer lookup supporting multiple search criteria with optional inactive customer inclusion"
    
    parameters:
      - name: customer_id
        type: integer
        required: false
        description: "Unique customer identifier for direct lookup"
        validation:
          minimum: 1
          maximum: 999999999
        
      - name: email
        type: string
        required: false
        description: "Customer email address for email-based lookup" 
        validation:
          pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
          max_length: 255
          
      - name: phone
        type: string
        required: false
        description: "Customer phone number (any format)"
        validation:
          min_length: 10
          max_length: 20
          
      - name: include_inactive
        type: boolean
        required: false
        default: false
        description: "Include customers with inactive status in results"
        
      - name: limit
        type: integer
        required: false
        default: 50
        description: "Maximum number of results to return"
        validation:
          minimum: 1
          maximum: 500

    statement: |
      WITH customer_search AS (
        SELECT 
          c.customer_id,
          c.customer_name,
          c.company_name,
          c.email_address,
          c.phone_number,
          c.status_code,
          c.created_date,
          c.modified_date,
          c.credit_limit,
          c.region_code,
          r.region_name,
          -- Get last order information
          lo.last_order_date,
          lo.last_order_amount,
          -- Get order count  
          COALESCE(oc.order_count, 0) as total_orders
        FROM customers c
        LEFT JOIN regions r ON c.region_code = r.region_code
        LEFT JOIN (
          SELECT 
            customer_id,
            MAX(order_date) as last_order_date,
            SUM(CASE WHEN order_date = (
              SELECT MAX(order_date) 
              FROM orders o2 
              WHERE o2.customer_id = o1.customer_id
            ) THEN total_amount ELSE 0 END) as last_order_amount
          FROM orders o1
          GROUP BY customer_id
        ) lo ON c.customer_id = lo.customer_id
        LEFT JOIN (
          SELECT customer_id, COUNT(*) as order_count
          FROM orders
          GROUP BY customer_id  
        ) oc ON c.customer_id = oc.customer_id
        WHERE 1=1
          -- Customer ID search
          AND (@customer_id IS NULL OR c.customer_id = @customer_id)
          -- Email search (case-insensitive)
          AND (@email IS NULL OR LOWER(c.email_address) = LOWER(@email))
          -- Phone search (flexible matching)
          AND (@phone IS NULL OR REPLACE(REPLACE(REPLACE(c.phone_number, '-', ''), ' ', ''), '(', '') 
               LIKE '%' || REPLACE(REPLACE(REPLACE(@phone, '-', ''), ' ', ''), '(', '') || '%')
          -- Status filtering
          AND (@include_inactive = true OR c.status_code = 'A')
      )
      SELECT *
      FROM customer_search
      ORDER BY 
        CASE WHEN customer_id = @customer_id THEN 0 ELSE 1 END,  -- Exact ID matches first
        total_orders DESC,                                        -- Then by order volume  
        modified_date DESC                                       -- Then by recent activity
      FETCH FIRST @limit ROWS ONLY
```

### Add Input Validation

The YAML tool system provides comprehensive parameter validation:

<CodeGroup>
```yaml String Validation
parameters:
  - name: email
    type: string
    validation:
      pattern: "^[\\w._%+-]+@[\\w.-]+\\.[A-Za-z]{2,}$"
      min_length: 5
      max_length: 255
      transform: "lowercase"  # Auto-transform input
```

```yaml Numeric Validation  
parameters:
  - name: customer_id
    type: integer
    validation:
      minimum: 1
      maximum: 999999999
      exclusive_minimum: false
```

```yaml Date/Time Validation
parameters:
  - name: start_date
    type: string
    format: date
    validation:
      pattern: "^\\d{4}-\\d{2}-\\d{2}$"
      after: "2020-01-01"
      before: "2030-12-31"
```

```yaml Boolean Logic
parameters:
  - name: include_inactive
    type: boolean
    default: false
    validation:
      allowed_values: [true, false]
```
</CodeGroup>

### Organize with Toolsets

Group related tools for better organization:

```yaml
toolsets:
  customer_management:
    description: "Comprehensive customer data operations for sales and support teams"
    tools:
      - customer_lookup
      - customer_orders
      - customer_payment_history
    tags: ["customers", "sales", "support"]
    
  customer_analytics:
    description: "Customer behavior analysis and reporting tools"  
    tools:
      - customer_lifetime_value
      - customer_segmentation
      - customer_churn_analysis
    tags: ["analytics", "reporting", "business-intelligence"]
```

### Complete the Configuration

```yaml
metadata:
  version: "2.1.0"
  description: "Customer relationship management tools with advanced search and analytics capabilities"
  author: "CRM Development Team"
  created: "2024-01-15"
  updated: "2024-03-20"
  tags: ["crm", "customers", "sales", "analytics"]
  changelog:
    - version: "2.1.0"
      date: "2024-03-20"
      changes: ["Added phone search capability", "Improved result ordering", "Added order count metrics"]
    - version: "2.0.0" 
      date: "2024-02-15"
      changes: ["Complete redesign with toolset organization", "Enhanced validation rules"]
    - version: "1.0.0"
      date: "2024-01-15"
      changes: ["Initial customer lookup tool"]
```

## Step 3: Advanced Parameter Patterns

### Conditional Parameters

Parameters can depend on other parameter values:

```yaml
tools:
  advanced_search:
    parameters:
      - name: search_type
        type: string
        required: true
        validation:
          allowed_values: ["id", "email", "phone", "name"]
          
      - name: search_value
        type: string
        required: true
        description: "Search value based on search_type"
        validation:
          # Conditional validation based on search_type
          conditional:
            - if: "search_type == 'email'"
              then:
                pattern: "^[\\w._%+-]+@[\\w.-]+\\.[A-Za-z]{2,}$"
            - if: "search_type == 'phone'"  
              then:
                pattern: "^[\\d\\s\\-\\(\\)\\+]{10,20}$"
            - if: "search_type == 'id'"
              then:
                pattern: "^\\d+$"
```

### Complex Validation Rules

```yaml
parameters:
  - name: date_range
    type: object
    required: false
    properties:
      start_date:
        type: string
        format: date
        required: true
      end_date:
        type: string  
        format: date
        required: true
    validation:
      custom: "end_date >= start_date"
      max_range_days: 365
      
  - name: filters
    type: array
    items:
      type: object
      properties:
        field:
          type: string
          validation:
            allowed_values: ["status", "region", "customer_type"]
        operator:
          type: string
          validation:
            allowed_values: ["eq", "ne", "in", "not_in"]
        value:
          type: string
          required: true
```

### Dynamic SQL Generation

Use parameters to build flexible SQL queries:

```yaml
statement: |
  SELECT 
    c.*,
    CASE 
      WHEN @include_metrics = true THEN (
        SELECT COUNT(*) FROM orders WHERE customer_id = c.customer_id
      ) ELSE NULL 
    END as order_count,
    CASE 
      WHEN @include_metrics = true THEN (
        SELECT SUM(total_amount) FROM orders WHERE customer_id = c.customer_id
      ) ELSE NULL
    END as lifetime_value
  FROM customers c
  WHERE 1=1
    {{ if customer_id }}
    AND c.customer_id = @customer_id
    {{ endif }}
    {{ if region_filter }}
    AND c.region_code IN ({{ join(region_filter, "','") }})
    {{ endif }}
    {{ if status_filter and status_filter != "all" }}
    AND c.status_code = @status_filter
    {{ endif }}
  ORDER BY 
    {{ if sort_by }}
    c.@sort_by {{ if sort_direction }}@sort_direction{{ else }}ASC{{ endif }}
    {{ else }}
    c.modified_date DESC
    {{ endif }}
  {{ if limit }}
  FETCH FIRST @limit ROWS ONLY
  {{ endif }}
```

## Step 4: Testing Your Tools

### Local Testing

1. **Save your YAML file** in the appropriate directory (e.g., `toolsets/customer-tools.yaml`)

2. **Start the server** with your configuration:
```bash
# Set environment variables
export CRM_DB_HOST="your-ibmi-host"
export CRM_DB_USER="your-username"
export CRM_DB_PASSWORD="your-password"

# Start the server
npm run start:http
```

3. **Test with MCP Inspector**:
```bash
npx @modelcontextprotocol/inspector http://localhost:3010
```

### Validation Testing

Test parameter validation with various inputs:

<CodeGroup>
```json Valid Request
{
  "name": "customer_lookup",
  "arguments": {
    "customer_id": 12345,
    "include_inactive": false,
    "limit": 10
  }
}
```

```json Invalid Request (should fail)
{
  "name": "customer_lookup", 
  "arguments": {
    "customer_id": -1,           // Below minimum
    "email": "invalid-email",    // Invalid format
    "limit": 1000               // Above maximum
  }
}
```

```json Edge Case Testing
{
  "name": "customer_lookup",
  "arguments": {
    "email": "CUSTOMER@EXAMPLE.COM",  // Test case handling
    "phone": "(555) 123-4567",        // Test phone formatting
    "include_inactive": true          // Test boolean handling
  }
}
```
</CodeGroup>

### Performance Testing

Monitor query performance and optimize as needed:

```yaml
# Add performance hints to your tools
tools:
  customer_lookup:
    # ... other configuration ...
    performance:
      expected_rows: 1-50
      max_execution_time: "5s"  
      cache_duration: "30s"
      index_hints:
        - "customers(customer_id)"
        - "customers(email_address)"
```

## Step 5: Best Practices

### SQL Best Practices

<CardGroup cols={2}>
  <Card title="Performance Optimization" icon="zap">
    **Query Efficiency**
    
    - Use appropriate indexes in WHERE clauses
    - Limit result sets with FETCH FIRST
    - Avoid SELECT * in production tools
    - Use EXISTS instead of IN for large datasets
  </Card>
  
  <Card title="Security Considerations" icon="shield">
    **Safe SQL Patterns**
    
    - Always use parameterized queries (@parameter)
    - Validate all input parameters
    - Avoid dynamic SQL construction
    - Use least-privilege database connections
  </Card>
</CardGroup>

### YAML Structure Best Practices

```yaml
# ✅ Good: Clear, descriptive names
tools:
  customer_lookup_by_email:
    source: primary-database
    description: "Find customer records using email address with fuzzy matching support"
    
# ❌ Bad: Vague, unclear purpose  
tools:
  lookup:
    source: db
    description: "Lookup stuff"
```

### Error Handling Patterns

```yaml
tools:
  robust_customer_search:
    statement: |
      BEGIN
        -- Validate inputs
        IF @customer_id IS NOT NULL AND @customer_id <= 0 THEN
          SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Customer ID must be positive';
        END IF;
        
        -- Main query with error handling
        SELECT 
          customer_id,
          customer_name,
          CASE 
            WHEN email_address IS NULL THEN 'No email on file'
            ELSE email_address
          END as email_display,
          COALESCE(phone_number, 'No phone on file') as phone_display
        FROM customers
        WHERE (@customer_id IS NULL OR customer_id = @customer_id)
          AND (@email IS NULL OR LOWER(email_address) = LOWER(@email))
          AND status_code IN ('A', 'P', 'S')  -- Only valid statuses
        ORDER BY customer_id
        FETCH FIRST COALESCE(@limit, 50) ROWS ONLY;
      END
```

## Step 6: Advanced Features

### Multi-Source Tools

Tools can query multiple databases:

```yaml
sources:
  customer-db:
    host: ${CUSTOMER_DB_HOST}
    # ... customer database config
    
  orders-db:
    host: ${ORDERS_DB_HOST}
    # ... orders database config
    
tools:
  customer_360_view:
    sources: [customer-db, orders-db]  # Multiple sources
    description: "Complete customer view across all systems"
    statement: |
      -- This requires federated queries or application-level joins
      -- Specific implementation depends on your IBM i setup
```

### Templated SQL

Use templates for complex, reusable SQL patterns:

```yaml
templates:
  standard_customer_fields: &customer_fields |
    c.customer_id,
    c.customer_name,
    c.email_address,
    c.phone_number,
    c.status_code,
    c.region_code
    
  standard_customer_joins: &customer_joins |
    LEFT JOIN regions r ON c.region_code = r.region_code
    LEFT JOIN customer_types ct ON c.customer_type = ct.type_code

tools:
  customer_summary:
    statement: |
      SELECT 
        *customer_fields,
        r.region_name,
        ct.type_description
      FROM customers c
      *customer_joins
      WHERE c.status_code = 'A'
```

### Tool Chaining

Design tools that work together:

```yaml
tools:
  get_customer_id:
    description: "Get customer ID from email - designed to chain with other tools"
    parameters:
      - name: email
        type: string
        required: true
    statement: |
      SELECT customer_id 
      FROM customers 
      WHERE LOWER(email_address) = LOWER(@email)
      FETCH FIRST 1 ROWS ONLY
      
  customer_order_history:
    description: "Get order history - designed to receive customer_id from other tools"
    parameters:
      - name: customer_id
        type: integer
        required: true
    statement: |
      SELECT 
        order_id,
        order_date,
        total_amount,
        order_status
      FROM orders
      WHERE customer_id = @customer_id
      ORDER BY order_date DESC
```

---

<Info>
YAML SQL tools provide an excellent balance of power and simplicity. Start with basic tools and gradually add complexity as you become more comfortable with the patterns and capabilities.
</Info>