---
title: "Writing YAML SQL Tools"
description: "Step-by-step guide to creating custom SQL tools using YAML configuration with real IBM i system examples from the prebuilt configurations."
---

# Writing YAML SQL Tools

YAML SQL tools provide a powerful way to create reusable, parameterized database operations without writing custom code. This guide walks through the complete process of designing, implementing, and deploying YAML-based SQL tools using real examples from the IBM i MCP Server's prebuilt configurations.

<Info>
YAML tools offer the perfect balance between the flexibility of dynamic SQL and the structure of custom TypeScript tools. The prebuilt configurations demonstrate production-ready patterns you can adapt for your own needs.
</Info>

<Tip>
Looking for the schema reference? See the complete YAML configuration reference at:
/sql-tools/yaml-configuration
</Tip>

## Why Choose YAML Tools?

<CardGroup cols={2}>
  <Card title="Developer Productivity" icon="rocket">
    **Fast Development Cycle**
    
    - No compilation required
    - Hot-reload configuration changes  
    - Immediate testing and iteration
    - Visual parameter validation
  </Card>
  
  <Card title="Enterprise Features" icon="shield-check">
    **Production-Ready Capabilities**
    
    - Built-in parameter validation
    - Automatic SQL injection protection
    - Connection pool optimization  
    - Comprehensive error handling
  </Card>
</CardGroup>

## Real YAML Tool Examples

Let's examine actual production tools from the prebuilt configurations to understand the patterns:

<Tabs>
<Tab title="System Performance Tools">
**From prebuiltconfigs/performance.yaml**

```yaml
sources:
  ibmi-system:
    host: ${DB2i_HOST}
    user: ${DB2i_USER}
    password: ${DB2i_PASS}
    port: 8076
    ignore-unauthorized: true

tools:
  system_status:
    source: ibmi-system
    description: "Overall system performance statistics with CPU, memory, and I/O metrics"
    parameters: []
    statement: |
      SELECT * FROM TABLE(QSYS2.SYSTEM_STATUS(RESET_STATISTICS=>'YES',DETAILED_INFO=>'ALL')) X

  active_job_info:
    source: ibmi-system
    description: "Find the top CPU consumers in QUSRWRK and QSYSWRK subsystems"
    parameters:
      - name: limit
        type: integer
        default: 10
        description: "Number of top CPU consumers to return"
    statement: |
      SELECT CPU_TIME, A.* FROM 
      TABLE(QSYS2.ACTIVE_JOB_INFO(SUBSYSTEM_LIST_FILTER => 'QUSRWRK,QSYSWRK')) A 
      ORDER BY CPU_TIME DESC 
      FETCH FIRST :limit ROWS ONLY

toolsets:
  performance:
    tools:
      - system_status
      - system_activity
      - memory_pools
      - active_job_info
```
</Tab>

<Tab title="System Administration Tools">
**From prebuiltconfigs/sys-admin.yaml**

```yaml
tools:
  describe_object:
    source: ibmi-system
    description: "Describe an SQL object by generating DDL definition"
    statement: |
      CALL QSYS2.GENERATE_SQL(
          DATABASE_OBJECT_NAME => :name,
          DATABASE_OBJECT_LIBRARY_NAME => :library,
          DATABASE_OBJECT_TYPE => :type,
          CREATE_OR_REPLACE_OPTION => '1',
          PRIVILEGES_OPTION => '0',
          STATEMENT_FORMATTING_OPTION => '0',
          SOURCE_STREAM_FILE_END_OF_LINE => 'LF',
          SOURCE_STREAM_FILE_CCSID => 1208
      )
    parameters:
      - name: name
        type: string
        description: "The name of the object"
        required: true
      - name: library
        type: string
        description: "The name of the library where the object is defined"
        required: true
        default: QSYS2
      - name: type
        type: string
        default: TABLE
        description: "Object type: TABLE, VIEW, PROCEDURE, FUNCTION, etc."

  search_services_by_name:
    source: ibmi-system
    description: "Case-insensitive search of services by name (contains match)"
    statement: |
      SELECT service_category,
             service_schema_name,
             service_name,
             sql_object_type,
             earliest_possible_release
      FROM qsys2.services_info
      WHERE UPPER(service_name) LIKE UPPER('%' CONCAT :name_contains CONCAT '%')
      ORDER BY service_category, service_schema_name, service_name
    parameters:
      - name: name_contains
        type: string
        description: "Substring to search for in SERVICE_NAME"
        required: true
        minLength: 2

toolsets:
  sysadmin_discovery:
    title: "Sys Admin Discovery"
    description: "High-level summaries and counts for services"
    tools:
      - list_service_categories
      - count_services_by_schema
      - count_services_by_sql_object_type
      
  sysadmin_search:
    title: "Sys Admin Search"
    description: "Search capabilities for service names and example usage"
    tools:
      - search_services_by_name
      - where_is_service
      - search_examples_for_keyword
```
</Tab>

<Tab title="Advanced Features">
**Security and Metadata**

```yaml
tools:
  execute_sql:
    source: ibmi-system
    description: "Execute arbitrary SQL statements"
    parameters:
      - name: sql
        type: string
        description: "The SQL statement to execute"
    statement: |
      :sql
    security:
      readOnly: true
      maxQueryLength: 15000
      forbiddenKeywords: ["TRUNCATE", "FORMAT", "DELETE", "UPDATE", "DROP"]
    domain: sysadmin
    category: discovery
    metadata:
      title: "Dynamic SQL Execution"
```
</Tab>
</Tabs>

## Step 1: Planning Your Tool

Before writing YAML, study the existing patterns and plan your tool:

### 1. Choose Your Domain

The prebuilt configurations organize tools by domain:

<CardGroup cols={3}>
  <Card title="Performance Monitoring" icon="chart-line">
    **System Health & Metrics**
    
    - System status and activity
    - Memory pools and storage
    - Job and subsystem monitoring
    - HTTP server metrics
  </Card>
  
  <Card title="System Administration" icon="cogs">
    **Discovery & Management**
    
    - Service discovery and search
    - Object description and DDL
    - Schema exploration
    - Administrative utilities
  </Card>
  
  <Card title="Custom Applications" icon="code">
    **Business-Specific Tools**
    
    - Application data queries
    - Business logic automation
    - Custom reporting
    - Integration endpoints
  </Card>
</CardGroup>

### 2. Study Existing Patterns

Learn from the prebuilt tools:

<CodeGroup>
```yaml Simple System Query (No Parameters)
system_status:
  source: ibmi-system
  description: "Overall system performance statistics"
  parameters: []
  statement: |
    SELECT * FROM TABLE(QSYS2.SYSTEM_STATUS()) X
```

```yaml Parameterized Search
search_services_by_name:
  source: ibmi-system
  description: "Case-insensitive search of services by name"
  parameters:
    - name: name_contains
      type: string
      description: "Substring to search for"
      required: true
      minLength: 2
  statement: |
    SELECT service_name, service_category
    FROM qsys2.services_info
    WHERE UPPER(service_name) LIKE UPPER('%' CONCAT :name_contains CONCAT '%')
```

```yaml Complex Procedure Call
describe_object:
  source: ibmi-system
  description: "Generate DDL for database objects"
  parameters:
    - name: name
      type: string
      required: true
    - name: library
      type: string
      required: true
      default: QSYS2
    - name: type
      type: string
      default: TABLE
  statement: |
    CALL QSYS2.GENERATE_SQL(
        DATABASE_OBJECT_NAME => :name,
        DATABASE_OBJECT_LIBRARY_NAME => :library,
        DATABASE_OBJECT_TYPE => :type
    )
```
</CodeGroup>

## Step 2: Building Your First Tool

Let's create a job monitoring tool based on the real IBM i performance patterns.

### 1. Start with the Source

Following the performance.yaml pattern:

```yaml
sources:
  ibmi-system:
    host: ${DB2i_HOST}
    user: ${DB2i_USER}
    password: ${DB2i_PASS}
    port: 8076
    ignore-unauthorized: true
```

### 2. Create a Simple Tool First

Build on the `active_job_info` pattern:

```yaml
tools:
  top_cpu_jobs:
    source: ibmi-system
    description: "Find jobs consuming the most CPU time"
    parameters:
      - name: limit
        type: integer
        default: 10
        description: "Number of top jobs to return"
    statement: |
      SELECT 
        job_name,
        job_user,
        job_number,
        cpu_time,
        job_status,
        subsystem_name
      FROM TABLE(QSYS2.ACTIVE_JOB_INFO()) A 
      ORDER BY cpu_time DESC 
      FETCH FIRST :limit ROWS ONLY
```

<Note>
Start simple! This follows the exact pattern from `active_job_info` but focuses on just the essential fields. You can expand it later.
</Note>

### 3. Add Parameter Validation

Enhance with real-world validation patterns:

```yaml
tools:
  job_search:
    source: ibmi-system
    description: "Search for jobs by name, user, or subsystem"
    parameters:
      - name: job_name_pattern
        type: string
        required: false
        description: "Job name pattern (use % for wildcards)"
        default: "%"
      - name: user_name
        type: string
        required: false
        description: "Filter by specific user"
      - name: subsystem_name
        type: string
        required: false
        description: "Filter by subsystem (e.g., QUSRWRK, QSYSWRK)"
      - name: limit
        type: integer
        default: 25
        description: "Maximum number of jobs to return"
        validation:
          min: 1
          max: 500
    statement: |
      SELECT 
        job_name,
        job_user,
        job_number,
        job_type,
        job_status,
        subsystem_name,
        cpu_time,
        elapsed_time
      FROM TABLE(QSYS2.ACTIVE_JOB_INFO()) A
      WHERE 1=1
        AND job_name LIKE UPPER(:job_name_pattern)
        AND (:user_name IS NULL OR job_user = UPPER(:user_name))
        AND (:subsystem_name IS NULL OR subsystem_name = UPPER(:subsystem_name))
      ORDER BY cpu_time DESC
      FETCH FIRST :limit ROWS ONLY
```

### 4. Organize with Toolsets

Follow the sysadmin pattern for organization:

```yaml
toolsets:
  job_monitoring:
    title: "Job Monitoring"
    description: "Tools for monitoring and analyzing job activity"
    tools:
      - top_cpu_jobs
      - job_search
      - subsystem_activity
      
  performance_analysis:
    title: "Performance Analysis" 
    description: "System performance monitoring and analysis"
    tools:
      - system_status
      - memory_pools
      - job_monitoring
```

## Step 3: Advanced Patterns from Prebuilt Configs

### 1. Complex Queries with CTEs

Learning from the sophisticated patterns in sys-admin.yaml:

```yaml
tools:
  service_analysis:
    source: ibmi-system
    description: "Analyze service distribution and usage patterns"
    parameters:
      - name: schema_filter
        type: string
        required: false
        description: "Filter by schema name (e.g., QSYS2, SYSTOOLS)"
    statement: |
      WITH service_stats AS (
        SELECT 
          service_schema_name,
          service_category,
          COUNT(*) as service_count,
          COUNT(DISTINCT sql_object_type) as object_types
        FROM qsys2.services_info
        WHERE (:schema_filter IS NULL OR service_schema_name = UPPER(:schema_filter))
        GROUP BY service_schema_name, service_category
      ),
      schema_summary AS (
        SELECT 
          service_schema_name,
          SUM(service_count) as total_services,
          COUNT(DISTINCT service_category) as categories
        FROM service_stats
        GROUP BY service_schema_name
      )
      SELECT 
        ss.service_schema_name,
        ss.service_category,
        ss.service_count,
        ss.object_types,
        sm.total_services,
        sm.categories,
        DECIMAL(FLOAT(ss.service_count) / FLOAT(sm.total_services) * 100, 5, 2) as pct_of_schema
      FROM service_stats ss
      JOIN schema_summary sm ON ss.service_schema_name = sm.service_schema_name
      ORDER BY sm.total_services DESC, ss.service_count DESC
```

### 2. Procedure Calls with Multiple Parameters

Following the `describe_object` pattern:

```yaml
tools:
  generate_insert_statements:
    source: ibmi-system
    description: "Generate INSERT statements for table data"
    parameters:
      - name: table_name
        type: string
        required: true
        description: "Name of the table"
      - name: schema_name
        type: string
        required: true
        default: QGPL
        description: "Schema containing the table"
      - name: row_limit
        type: integer
        default: 100
        description: "Maximum rows to generate INSERT statements for"
    statement: |
      CALL QSYS2.GENERATE_SQL(
          DATABASE_OBJECT_NAME => :table_name,
          DATABASE_OBJECT_LIBRARY_NAME => :schema_name,
          DATABASE_OBJECT_TYPE => 'TABLE',
          STATEMENT_TYPES => 'INSERT',
          ROWS_TO_INSERT => :row_limit,
          CREATE_OR_REPLACE_OPTION => '1'
      )
```

### 3. Security and Domain Classifications

Following the metadata patterns:

```yaml
tools:
  sensitive_data_scan:
    source: ibmi-system
    description: "Scan for tables with potentially sensitive column names"
    parameters:
      - name: schema_pattern
        type: string
        default: "%"
        description: "Schema pattern to search"
    statement: |
      SELECT DISTINCT
        table_schema,
        table_name,
        column_name,
        data_type,
        CASE 
          WHEN UPPER(column_name) LIKE '%SSN%' OR UPPER(column_name) LIKE '%SOCIAL%' THEN 'SSN'
          WHEN UPPER(column_name) LIKE '%CREDIT%' OR UPPER(column_name) LIKE '%CARD%' THEN 'FINANCIAL'
          WHEN UPPER(column_name) LIKE '%EMAIL%' OR UPPER(column_name) LIKE '%MAIL%' THEN 'EMAIL'
          WHEN UPPER(column_name) LIKE '%PHONE%' OR UPPER(column_name) LIKE '%TEL%' THEN 'PHONE'
          ELSE 'OTHER'
        END as sensitivity_type
      FROM qsys2.syscolumns
      WHERE table_schema LIKE UPPER(:schema_pattern)
        AND table_schema NOT LIKE 'Q%'
        AND (
          UPPER(column_name) LIKE '%SSN%' OR
          UPPER(column_name) LIKE '%SOCIAL%' OR
          UPPER(column_name) LIKE '%CREDIT%' OR
          UPPER(column_name) LIKE '%CARD%' OR
          UPPER(column_name) LIKE '%EMAIL%' OR
          UPPER(column_name) LIKE '%PHONE%'
        )
      ORDER BY sensitivity_type, table_schema, table_name
    domain: security
    category: audit
    security:
      readOnly: true
      restrictive: true
```

## Step 4: Testing Your Tools

### 1. Start the MCP Server

```bash
# Set your environment variables
export DB2i_HOST="your-ibmi-system"
export DB2i_USER="your-username"  
export DB2i_PASS="your-password"

# Copy your YAML to the appropriate directory
cp job-monitoring.yaml prebuiltconfigs/

# Start the server
npm run start:http
```

### 2. Test with MCP Inspector

```bash
# Launch MCP Inspector to test your tools
npx @modelcontextprotocol/inspector http://localhost:3010

# Or test directly with curl
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Content-Type: application/json" \
  -d '{
    "name": "top_cpu_jobs",
    "arguments": {
      "limit": 5
    }
  }'
```

### 3. Validate Against Real Data

Test with actual IBM i system queries:

<CodeGroup>
```bash Test System Status
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Content-Type: application/json" \
  -d '{
    "name": "system_status",
    "arguments": {}
  }'
```

```bash Test Service Search  
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Content-Type: application/json" \
  -d '{
    "name": "search_services_by_name", 
    "arguments": {
      "name_contains": "SYSTEM"
    }
  }'
```

```bash Test Object Description
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Content-Type: application/json" \
  -d '{
    "name": "describe_object",
    "arguments": {
      "name": "SYSTEM_STATUS",
      "library": "QSYS2",
      "type": "TABLE"
    }
  }'
```
</CodeGroup>

## Step 5: Best Practices from Prebuilt Configs

### 1. Parameter Design Patterns

<CardGroup cols={2}>
  <Card title="Optional vs Required" icon="toggle">
    **Smart Defaults**
    
    Study how the prebuilt tools use optional parameters with sensible defaults:
    - `limit` parameters default to reasonable values (10-25)
    - Search patterns default to "%" (all)
    - Object types default to most common ("TABLE")
  </Card>
  
  <Card title="Validation Patterns" icon="check">
    **Real-World Constraints**
    
    - String lengths match IBM i object name limits
    - Numeric ranges prevent system overload
    - Enum values match actual IBM i constants
  </Card>
</CardGroup>

### 2. SQL Query Patterns

<Tabs>
<Tab title="System Catalog Queries">
**Leverage IBM i System Views**

```sql
-- Pattern: Use QSYS2 system services extensively
SELECT * FROM QSYS2.ACTIVE_JOB_INFO()
SELECT * FROM TABLE(QSYS2.SYSTEM_STATUS()) 
SELECT * FROM QSYS2.SERVICES_INFO
```

The prebuilt configurations make heavy use of IBM i's system catalog views for reliable, documented data access.
</Tab>

<Tab title="Parameter Binding">
**Consistent Parameter Syntax**

```sql
-- Pattern: Use :parameter_name for binding
WHERE job_name LIKE UPPER(:job_pattern)
AND (:user_filter IS NULL OR job_user = :user_filter)
FETCH FIRST :limit ROWS ONLY
```

All prebuilt tools use `:parameter` syntax consistently, with NULL checking for optional parameters.
</Tab>

<Tab title="Result Ordering">
**Meaningful Sort Orders**

```sql
-- Pattern: Order by most useful/relevant first
ORDER BY cpu_time DESC           -- Performance tools
ORDER BY service_count DESC      -- Discovery tools  
ORDER BY service_category, service_name  -- Browse tools
```

Results are always ordered to put the most relevant information first.
</Tab>
</Tabs>

### 3. Toolset Organization

Follow the three-tier pattern from sys-admin.yaml:

```yaml
toolsets:
  # Tier 1: Discovery - High-level overview
  discovery:
    description: "High-level summaries and counts"
    tools:
      - overview_stats
      - category_counts
      - schema_summary
      
  # Tier 2: Browse - Explore categories  
  browse:
    description: "Explore specific categories and types"
    tools:
      - list_by_category
      - list_by_schema
      - filter_by_type
      
  # Tier 3: Search - Find specific items
  search:
    description: "Search and lookup specific items"
    tools:
      - search_by_name
      - find_by_pattern
      - lookup_details
```

## Step 6: Deployment and Integration

### 1. File Organization

Follow the prebuilt configuration structure:

```bash
prebuiltconfigs/
├── performance.yaml      # System performance monitoring
├── sys-admin.yaml        # System administration tools  
├── your-domain.yaml      # Your custom tools
└── README.md            # Documentation
```

### 2. Agent Integration  

Your tools automatically work with the FilteredMCPTools system:

```python
# Agents can use your custom toolsets
from tools.filtered_mcp_tools import FilteredMCPTools

# Use your custom toolset
custom_tools = FilteredMCPTools(
    url="http://127.0.0.1:3010/mcp",
    transport="streamable-http",
    toolsets=["job_monitoring"]  # Your custom toolset
)
```

### 3. Production Considerations

<CardGroup cols={2}>
  <Card title="Performance" icon="zap">
    **Query Optimization**
    
    - Use FETCH FIRST consistently
    - Index-aware WHERE clauses
    - Avoid SELECT * in production
    - Monitor execution times
  </Card>
  
  <Card title="Security" icon="shield">
    **Access Control**
    
    - Use service accounts with minimal privileges
    - Implement read-only restrictions where possible
    - Validate all input parameters
    - Log access and usage
  </Card>
</CardGroup>

---

<Info>
The prebuilt configurations provide battle-tested patterns for IBM i system interaction. Start with these examples and adapt them to your specific needs while maintaining the same quality and structure standards.
</Info>
