---
title: "Authentication Overview"
description: "Comprehensive guide to authentication and authorization options for the IBM i MCP Server including JWT, OAuth, and security best practices."
---

# Authentication Overview

The IBM i MCP Server provides flexible authentication options to secure access to your database tools and resources. Authentication is available when using HTTP transport mode and supports multiple strategies from development-friendly no-auth to enterprise-grade OAuth integration.

<Note>
Authentication is only available when using **HTTP transport mode**. STDIO transport relies on process-level security and operating system permissions for access control.
</Note>

## Authentication Architecture

<Frame>
<img src="/images/auth-architecture.svg" alt="IBM i MCP Server Authentication Architecture" />
</Frame>

The authentication system is built on a pluggable architecture that allows different authentication strategies while maintaining consistent authorization enforcement:

<CardGroup cols={3}>
  <Card title="Authentication Layer" icon="key">
    **Identity Verification**
    
    Validates client credentials and establishes identity using JWT tokens, OAuth, or no authentication.
  </Card>
  
  <Card title="Authorization Layer" icon="shield">
    **Permission Enforcement**
    
    Controls access to specific tools and resources based on authenticated identity and assigned scopes.
  </Card>
  
  <Card title="Audit Layer" icon="clipboard">
    **Security Logging**
    
    Comprehensive logging of authentication events, access attempts, and security-related activities.
  </Card>
</CardGroup>

## Authentication Modes

Choose the authentication mode that best fits your deployment environment and security requirements:

<Tabs>
<Tab title="None (Development)">
**Best for**: Local development, testing, trusted environments

```bash
MCP_AUTH_MODE=none
```

**Characteristics**:
- ✅ Quick setup for development
- ✅ No configuration complexity
- ✅ Suitable for localhost-only deployments
- ⚠️ **Not suitable for production**
- ⚠️ No access controls or audit trail

**Use Cases**:
- Local development and testing
- Proof-of-concept deployments
- Internal tools in secure networks
</Tab>

<Tab title="JWT (Recommended)">
**Best for**: Most production deployments, API integrations

```bash
MCP_AUTH_MODE=jwt
MCP_AUTH_SECRET_KEY=your-secret-key-min-32-chars-long
```

**Characteristics**:
- ✅ Industry standard authentication
- ✅ Stateless and scalable
- ✅ Fine-grained scope control
- ✅ Easy integration with applications
- ✅ Self-contained tokens

**Use Cases**:
- Production API deployments
- Microservices integration
- Custom application backends
- Automated agent systems
</Tab>

<Tab title="OAuth 2.0 (Enterprise)">
**Best for**: Enterprise environments, existing OAuth infrastructure

```bash
MCP_AUTH_MODE=oauth
OAUTH_ISSUER_URL=https://auth.company.com
OAUTH_AUDIENCE=ibmi-mcp-server
```

**Characteristics**:
- ✅ Enterprise-grade security
- ✅ Centralized identity management
- ✅ Integration with existing auth systems
- ✅ Advanced token validation
- ⚠️ Requires OAuth 2.0 infrastructure

**Use Cases**:
- Enterprise deployments
- Integration with Active Directory
- SSO-enabled environments
- Compliance-required deployments
</Tab>
</Tabs>

## Security Model

### Transport Security

<Warning>
Always use HTTPS in production environments. The MCP server supports TLS termination through reverse proxies or load balancers.
</Warning>

**Recommended Setup**:
- **Development**: HTTP on localhost only
- **Production**: HTTPS with valid SSL certificates
- **Load Balancer**: TLS termination at infrastructure layer

### Token-Based Authentication

The server uses industry-standard token-based authentication:

<Steps>
<Step title="Token Acquisition">
Clients obtain authentication tokens through configured authentication providers:

```http
POST /auth/token
Content-Type: application/json

{
  "grant_type": "client_credentials",
  "client_id": "your-client-id", 
  "client_secret": "your-client-secret",
  "scope": "ibmi:read ibmi:execute"
}
```
</Step>

<Step title="Token Usage">
Include tokens in MCP requests via Authorization header:

```http
POST /mcp/tools/call
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "name": "system_status",
  "arguments": {}
}
```
</Step>

<Step title="Token Validation">
Server validates tokens on every request:

- **Signature verification** (JWT) or **introspection** (OAuth)
- **Expiration checking**
- **Audience validation**
- **Scope verification** for requested operations
</Step>
</Steps>

## Authorization and Scopes

The server implements fine-grained authorization through scopes that control access to different operations:

### Built-in Scopes

<ParamField path="ibmi:read" type="scope">
  **Read-only database access**
  
  Allows execution of SELECT queries and read-only tools. Suitable for monitoring and reporting applications.
  
  **Grants access to**:
  - System monitoring tools
  - Database query tools  
  - Resource listing operations
  - Read-only administrative tools
</ParamField>

<ParamField path="ibmi:execute" type="scope">
  **Dynamic SQL execution**
  
  Allows execution of the `execute_sql` tool with safety restrictions. Required for ad-hoc query capabilities.
  
  **Grants access to**:
  - Dynamic SQL execution (with restrictions)
  - Custom query building
  - Data exploration tools
</ParamField>

<ParamField path="ibmi:admin" type="scope">
  **Administrative operations**
  
  Allows access to administrative tools and potentially destructive operations. Use with caution.
  
  **Grants access to**:
  - User management tools
  - System configuration queries
  - Job control operations
  - Administrative utilities
</ParamField>

<ParamField path="ibmi:generate" type="scope">
  **AI-assisted SQL generation**
  
  Allows use of AI-powered SQL generation tools. Requires OpenRouter API configuration.
  
  **Grants access to**:
  - SQL generation from natural language
  - Query optimization suggestions
  - AI-assisted database exploration
</ParamField>

### Scope-Based Tool Protection

Tools can be protected by specific scopes using the `withRequiredScopes` utility:

```typescript
// Example: Protect administrative tools
server.registerTool(
  "user_management",
  { /* tool config */ },
  withRequiredScopes(["ibmi:admin"], async (params, context) => {
    // Tool implementation
    return await userManagementLogic(params, context);
  })
);

// Example: Read-only tools
server.registerTool(
  "system_status", 
  { /* tool config */ },
  withRequiredScopes(["ibmi:read"], async (params, context) => {
    return await systemStatusLogic(params, context);
  })
);
```

## Authentication Flow Examples

### JWT Authentication Flow

<Steps>
<Step title="Configure Server">
Set up JWT authentication mode:

```bash
# Environment configuration
MCP_AUTH_MODE=jwt
MCP_AUTH_SECRET_KEY=your-very-secure-secret-key-at-least-32-characters
MCP_HTTP_PORT=3010
```
</Step>

<Step title="Generate Token">
Create JWT tokens for clients (implementation depends on your application):

```javascript
const jwt = require('jsonwebtoken');

const token = jwt.sign(
  {
    sub: 'client-app-001',           // Subject (client identifier)
    aud: 'ibmi-mcp-server',          // Audience
    scope: 'ibmi:read ibmi:execute', // Granted permissions
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours
  },
  process.env.MCP_AUTH_SECRET_KEY,
  { algorithm: 'HS256' }
);
```
</Step>

<Step title="Make Authenticated Requests">
Use the token in MCP tool calls:

```bash
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "system_status",
    "arguments": {}
  }'
```
</Step>
</Steps>

### OAuth 2.0 Authentication Flow

<Steps>
<Step title="Configure Server">
Set up OAuth authentication mode:

```bash
# Environment configuration
MCP_AUTH_MODE=oauth
OAUTH_ISSUER_URL=https://auth.your-company.com
OAUTH_AUDIENCE=ibmi-mcp-server
MCP_HTTP_PORT=3010
```
</Step>

<Step title="Obtain OAuth Token">
Get token from your OAuth provider:

```bash
# Example with standard OAuth 2.0 client credentials flow
curl -X POST https://auth.your-company.com/oauth/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret" \
  -d "scope=ibmi:read ibmi:execute"
```
</Step>

<Step title="Use Token with MCP Server">
Include the OAuth token in requests:

```bash
curl -X POST http://localhost:3010/mcp/tools/call \
  -H "Authorization: Bearer ${OAUTH_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "execute_sql",
    "arguments": {
      "sql": "SELECT * FROM TABLE(QSYS2.SYSTEM_STATUS()) FETCH FIRST 5 ROWS ONLY"
    }
  }'
```
</Step>
</Steps>

## CORS Configuration

Configure Cross-Origin Resource Sharing for web applications:

```bash
# Allow specific origins
MCP_ALLOWED_ORIGINS=https://app.company.com,https://admin.company.com

# Allow all origins (development only)
MCP_ALLOWED_ORIGINS=*
```

**CORS Headers Automatically Handled**:
- `Access-Control-Allow-Origin`
- `Access-Control-Allow-Methods`
- `Access-Control-Allow-Headers`
- `Access-Control-Allow-Credentials`

## Security Best Practices

### Token Management

<CardGroup cols={2}>
  <Card title="Token Lifecycle" icon="clock">
    **Manage Token Expiration**
    
    - Use reasonable expiration times (1-24 hours)
    - Implement automatic token refresh
    - Handle expired token scenarios gracefully
    - Log token lifecycle events
  </Card>
  
  <Card title="Secret Management" icon="key">
    **Protect Signing Secrets**
    
    - Use cryptographically secure random keys
    - Store secrets in environment variables
    - Rotate secrets regularly
    - Never commit secrets to version control
  </Card>
</CardGroup>

### Network Security

<AccordionGroup>
<Accordion title="TLS Configuration">
Always use HTTPS in production:

```nginx
# Nginx reverse proxy configuration
server {
    listen 443 ssl http2;
    server_name mcp-server.company.com;
    
    ssl_certificate /path/to/certificate.pem;
    ssl_certificate_key /path/to/private-key.pem;
    
    location / {
        proxy_pass http://localhost:3010;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Authorization $http_authorization;
    }
}
```
</Accordion>

<Accordion title="Network Isolation">
Isolate the MCP server in secure network segments:

```yaml
# Docker network isolation
networks:
  mcp-internal:
    driver: bridge
    internal: true
  
  mcp-external:
    driver: bridge

services:
  ibmi-mcp-server:
    networks:
      - mcp-internal  # Internal communication
      - mcp-external  # External API access
```
</Accordion>
</AccordionGroup>

### Audit and Monitoring

<Steps>
<Step title="Authentication Logging">
All authentication events are automatically logged:

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "level": "info",
  "event": "authentication_success",
  "client_id": "app-001",
  "scopes": ["ibmi:read", "ibmi:execute"],
  "remote_ip": "192.168.1.100"
}
```
</Step>

<Step title="Authorization Tracking">
Authorization decisions are logged with context:

```json
{
  "timestamp": "2024-01-15T10:30:15Z", 
  "level": "warn",
  "event": "authorization_denied",
  "tool": "execute_sql",
  "required_scope": "ibmi:execute",
  "client_scopes": ["ibmi:read"],
  "client_id": "limited-app"
}
```
</Step>

<Step title="Security Monitoring">
Monitor for suspicious authentication patterns:

- Multiple failed authentication attempts
- Unusual access patterns or timing
- Requests from unexpected IP addresses
- Scope privilege escalation attempts
</Step>
</Steps>

## Development vs Production

### Development Configuration

```bash title=".env.development"
# Minimal auth for development
MCP_AUTH_MODE=none
MCP_HTTP_HOST=127.0.0.1
MCP_HTTP_PORT=3010
MCP_ALLOWED_ORIGINS=http://localhost:3000

# Enable debug logging
MCP_LOG_LEVEL=debug
```

### Production Configuration  

```bash title=".env.production"
# JWT authentication for production
MCP_AUTH_MODE=jwt
MCP_AUTH_SECRET_KEY=${JWT_SECRET_FROM_VAULT}

# Secure network configuration
MCP_HTTP_HOST=0.0.0.0
MCP_HTTP_PORT=3010
MCP_ALLOWED_ORIGINS=https://app.company.com

# Production logging
MCP_LOG_LEVEL=info
OTEL_ENABLED=true
```

## Troubleshooting Authentication

<AccordionGroup>
<Accordion title="Token Validation Failures">
**Error**: `Invalid or expired token`

**Common Causes**:
- Token has expired
- Wrong signing secret/key
- Malformed token structure
- Incorrect audience claim

**Solutions**:
- Check token expiration with JWT decoder
- Verify `MCP_AUTH_SECRET_KEY` matches token signing key
- Validate token structure and required claims
- Ensure audience matches server configuration
</Accordion>

<Accordion title="Insufficient Permissions">
**Error**: `Insufficient permissions for requested operation`

**Common Causes**:
- Token lacks required scopes
- Tool requires higher privileges
- Scope mapping misconfiguration

**Solutions**:
- Check token scopes match tool requirements
- Review tool protection configuration
- Update client credentials to include needed scopes
</Accordion>

<Accordion title="CORS Issues">
**Error**: `CORS policy blocked the request`

**Common Causes**:
- Origin not in allowed origins list
- Missing preflight headers
- Credentials not allowed

**Solutions**:
- Add origin to `MCP_ALLOWED_ORIGINS`
- Check browser developer tools for CORS details
- Ensure credentials are properly configured
</Accordion>
</AccordionGroup>

## Future Authentication Features

<Note>
**Coming Soon**: The following authentication features are planned for future releases:

- **API Key Authentication**: Simple API key-based auth for service accounts
- **mTLS Support**: Mutual TLS authentication for high-security environments  
- **SAML Integration**: SAML 2.0 support for enterprise identity providers
- **Role-Based Access Control**: More granular permission management
- **Session Management**: Optional stateful sessions for web applications
</Note>

---

<Info>
Choose the authentication mode that matches your security requirements and infrastructure. Start with JWT for most production deployments, and consider OAuth for enterprise environments with existing identity management systems.
</Info>
