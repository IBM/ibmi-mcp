# mcp-ts-template Developer Cheatsheet

This cheatsheet provides quick references for common patterns, utilities, and server configuration within the `mcp-ts-template` codebase.

## Server Transports & Configuration

The server can run using different communication transports, configured via environment variables.

- **`MCP_TRANSPORT_TYPE`**: Specifies the transport.
    - `"stdio"` (Default): Uses standard input/output for communication. Suitable for direct integration with parent processes.
    - `"http"`: Uses Streamable HTTP Server-Sent Events (SSE) for communication. Runs an Express server.
- **`MCP_HTTP_PORT`**: Port for the HTTP server (Default: `3000`). Used only if `MCP_TRANSPORT_TYPE=http`.
- **`MCP_HTTP_HOST`**: Host address for the HTTP server (Default: `127.0.0.1`). Used only if `MCP_TRANSPORT_TYPE=http`.
- **`MCP_ALLOWED_ORIGINS`**: Comma-separated list of allowed origins for HTTP requests (e.g., `http://localhost:8080,https://my-frontend.com`). Used only if `MCP_TRANSPORT_TYPE=http` and `MCP_HTTP_HOST` is not localhost.

### HTTP Transport Details (`MCP_TRANSPORT_TYPE=http`)

- **Endpoint**: A single endpoint `/mcp` handles all communication.
    - `POST /mcp`: Client sends requests to the server. Requires `mcp-session-id` header for subsequent requests after initialization.
    - `GET /mcp`: Server sends responses/notifications to the client via Server-Sent Events (SSE). Requires `mcp-session-id` header.
    - `DELETE /mcp`: Client signals session termination. Requires `mcp-session-id` header.
- **Session Management**: Each client connection establishes a session identified by the `mcp-session-id` header. The server maintains state per session.
- **Security**: Basic origin checking is implemented. Configure `MCP_ALLOWED_ORIGINS` for production environments when not running on localhost.

### Running the Server

- **Stdio**: `npm start` or `node dist/index.js`
- **HTTP**: `MCP_TRANSPORT_TYPE=http npm start` or `MCP_TRANSPORT_TYPE=http node dist/index.js` (optionally set `MCP_HTTP_PORT`, `MCP_HTTP_HOST`, `MCP_ALLOWED_ORIGINS`).

## Core Utilities Integration
```markdown
### 1. Logging (`src/utils/logger.ts`)

- **Purpose**: Structured logging for debugging and monitoring. Logs to files in the `logs/` directory.
- **Usage**: Import the singleton `logger` instance. Pass a `context` object (usually `RequestContext`) for correlation.

```typescript
import { logger } from './src/utils/logger.js';
import { RequestContext } from './src/utils/requestContext.js'; // Or OperationContext

// Inside a function or handler
const operationContext: RequestContext = /* ... get or create context ... */;

logger.info("Processing request", operationContext);
logger.debug("Detailed step info", { ...operationContext, data: someData });
logger.warn("Potential issue detected", operationContext);
logger.error("An error occurred", operationContext, new Error("Something failed")); // Pass error object
```

- **Key Files**:
  - `src/utils/logger.ts`: Logger implementation.
  - `logs/`: Directory where log files are stored (`combined.log`, `error.log`, etc.).

### 2. Error Handling (`src/types-global/errors.ts`, `src/utils/errorHandler.ts`)

- **Purpose**: Standardized error objects (`McpError`) and centralized handling (`ErrorHandler`). Automatically determines error codes based on type/patterns.
- **Usage**:
  - Use `ErrorHandler.tryCatch` to wrap operations that might fail.
  - Throw `McpError` for specific, categorized errors using `BaseErrorCode`.
  - `ErrorHandler` automatically logs errors with context and sanitized input.

```typescript
import { ErrorHandler } from './src/utils/errorHandler.js';
import { McpError, BaseErrorCode } from './src/types-global/errors.js';
import { RequestContext } from './src/utils/requestContext.js';

async function performTask(input: any, context: RequestContext) {
  return await ErrorHandler.tryCatch(
    async () => {
      if (!input) {
        throw new McpError(BaseErrorCode.VALIDATION_ERROR, "Input cannot be empty", context);
      }
      // ... perform task logic ...
      const result = await someAsyncOperation(input);
      return result;
    },
    {
      operation: 'performTask',
      context: context,
      input: input, // Input is automatically sanitized for logging
      errorCode: BaseErrorCode.INTERNAL_ERROR, // Default code if unexpected error occurs
      critical: false // Or true if failure should halt the process
    }
  );
}
```

- **Key Files**:
  - `src/types-global/errors.ts`: Defines `McpError` and `BaseErrorCode`.
  - `src/utils/errorHandler.ts`: Provides `ErrorHandler.tryCatch`, `handleError`, `determineErrorCode`.

### 3. Request Context (`src/utils/requestContext.ts`)

- **Purpose**: Track and correlate operations related to a single request or workflow using a unique `requestId`.
- **Usage**:
  - Create context at the beginning of an operation using `requestContextService.createRequestContext`.
  - Pass the context object down through function calls.
  - Include the context object when logging or creating errors.

```typescript
import { requestContextService, RequestContext } from './src/utils/requestContext.js';
import { logger } from './src/utils/logger.js';

function handleIncomingRequest(requestData: any) {
  const context: RequestContext = requestContextService.createRequestContext({
    operation: 'HandleIncomingRequest',
    // Add any other relevant initial context
    initialData: requestData.id
  });

  logger.info("Received request", context);
  processSubTask(requestData.payload, context);
}

function processSubTask(payload: any, parentContext: RequestContext) {
  // Create a derived context if needed, or just pass the parent context
  const subTaskContext = { ...parentContext, subOperation: 'ProcessSubTask' };
  logger.debug("Processing sub-task", subTaskContext);
  // ... logic ...
}
```

- **Key Files**:
  - `src/utils/requestContext.ts`: Defines `RequestContext` interface and `requestContextService`.

### 4. ID Generation (`src/utils/idGenerator.ts`)

- **Purpose**: Generate unique, prefixed IDs for different entity types and standard UUIDs.
- **Usage**: Configure prefixes (if needed) and use `idGenerator.generateForEntity` or `generateUUID`.

```typescript
import { idGenerator, generateUUID } from './src/utils/idGenerator.js';

// Configure prefixes (e.g., during initialization)
idGenerator.setEntityPrefixes({
  project: 'PROJ',
  task: 'TASK'
});

// Generate IDs
const projectId = idGenerator.generateForEntity('project'); // e.g., "PROJ_A6B3J0"
const taskId = idGenerator.generateForEntity('task', { length: 8 }); // e.g., "TASK_C9D4E1F2"
const standardUuid = generateUUID(); // e.g., "123e4567-e89b-12d3-a456-426614174000"

// Validate IDs
const isValid = idGenerator.isValid(projectId, 'project'); // true
const entityType = idGenerator.getEntityType(taskId); // "task"
```

- **Key Files**:
  - `src/utils/idGenerator.ts`: `IdGenerator` class, default `idGenerator` instance, and `generateUUID` function.

### 5. Sanitization (`src/utils/sanitization.ts`)

- **Purpose**: Clean and validate input data (HTML, paths, numbers, URLs, JSON) to prevent security issues. Also sanitizes objects for logging.
- **Usage**: Import the singleton `sanitization` instance or the `sanitizeInputForLogging` helper.

```typescript
import { sanitization, sanitizeInputForLogging } from './src/utils/sanitization.js';

const unsafeHtml = '<script>alert("xss")</script><p>Safe content</p>';
const safeHtml = sanitization.sanitizeHtml(unsafeHtml); // "<p>Safe content</p>"

const unsafePath = '../../etc/passwd';
try {
  const safePath = sanitization.sanitizePath(unsafePath, { rootDir: '/app/data' });
} catch (error) {
  // Handle McpError (BaseErrorCode.VALIDATION_ERROR)
}

const userInput = " 123.45 ";
const num = sanitization.sanitizeNumber(userInput, 0, 1000); // 123.45

const unsafeUrl = 'javascript:alert("bad")';
try {
    const safeUrl = sanitization.sanitizeUrl(unsafeUrl);
} catch (error) {
    // Handle McpError (BaseErrorCode.VALIDATION_ERROR)
}

// Sanitize objects for logging (removes sensitive fields)
const sensitiveData = { user: 'admin', password: 'pwd', token: 'abc' };
const safeLogData = sanitizeInputForLogging(sensitiveData);
// safeLogData = { user: 'admin', password: '[REDACTED]', token: '[REDACTED]' }
```

- **Key Files**:
  - `src/utils/sanitization.ts`: `Sanitization` class, `sanitization` instance, and `sanitizeInputForLogging` function.

### 6. JSON Parsing (`src/utils/jsonParser.ts`)

- **Purpose**: Parse potentially partial/incomplete JSON strings. Handles optional `<think>` blocks at the beginning of the input, logging their content.
- **Usage**: Import the singleton `jsonParser` instance. Use `Allow` constants for partial parsing options.

```typescript
import { jsonParser, Allow } from './src/utils/jsonParser.js';
import { RequestContext } from './src/utils/requestContext.js';

const partialJson = '<think>Parsing JSON...</think>{"key": "value", "incomplete": ';
const context: RequestContext = /* ... */;

try {
  // Parse allowing incomplete structures
  const parsed = jsonParser.parse(partialJson, Allow.ALL, context);
  // parsed = { key: 'value', incomplete: undefined }

  // Parse requiring complete JSON (after <think> block)
  const completeJson = '<think>Thinking...</think>{"complete": true}';
  const fullParsed = jsonParser.parse(completeJson, Allow.NONE, context);
  // fullParsed = { complete: true }

} catch (error) {
  // Handle McpError (BaseErrorCode.VALIDATION_ERROR)
}
```

- **Key Files**:
  - `src/utils/jsonParser.ts`: `JsonParser` class, `jsonParser` instance, and `Allow` enum.

### 7. Rate Limiting (`src/utils/rateLimiter.ts`)

- **Purpose**: Implement rate limiting based on a key (e.g., user ID, IP address).
- **Usage**: Import the singleton `rateLimiter` instance. Use `check` to enforce limits.

```typescript
import { rateLimiter } from './src/utils/rateLimiter.js';
import { RequestContext } from './src/utils/requestContext.js';

const userId = 'user123';
const context: RequestContext = /* ... */;

try {
  // Check rate limit for the user
  rateLimiter.check(userId, context);

  // ... proceed with the operation ...

} catch (error) {
  // Handle McpError (BaseErrorCode.RATE_LIMITED)
  if (error instanceof McpError && error.code === BaseErrorCode.RATE_LIMITED) {
    console.warn(`Rate limit exceeded for ${userId}. Wait ${error.details?.waitTime}s.`);
  } else {
    // Handle other errors
  }
}

// Optionally configure the limiter (e.g., during initialization)
rateLimiter.configure({ windowMs: 60 * 1000, maxRequests: 10 });
```

- **Key Files**:
  - `src/utils/rateLimiter.ts`: `RateLimiter` class and `rateLimiter` instance.

### 8. Token Counting (`src/utils/tokenCounter.ts`)

- **Purpose**: Estimate the number of tokens for text or chat messages using the `tiktoken` library (specifically with the `gpt-4o` model tokenizer).
- **Usage**: Import `countTokens` for plain text or `countChatTokens` for chat message arrays.

```typescript
import { countTokens, countChatTokens } from './src/utils/tokenCounter.js';
import { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
import { RequestContext } from './src/utils/requestContext.js';

const text = "This is some sample text.";
const context: RequestContext = /* ... */;

async function calculateTokens() {
  try {
    const textTokens = await countTokens(text, context);
    console.log(`Text tokens: ${textTokens}`);

    const messages: ChatCompletionMessageParam[] = [
      { role: 'system', content: 'You are helpful.' },
      { role: 'user', content: 'Hello!' }
    ];
    const chatTokens = await countChatTokens(messages, context);
    console.log(`Chat tokens: ${chatTokens}`);

  } catch (error) {
    // Handle McpError (BaseErrorCode.INTERNAL_ERROR if tiktoken fails)
  }
}
```

- **Key Files**:
  - `src/utils/tokenCounter.ts`: Provides `countTokens` and `countChatTokens` functions.

## Adding New Features

### Adding a Tool

1.  **Directory**: `src/mcp-server/tools/yourToolName/`
2.  **Logic (`logic.ts`)**: Define input/output types, validation schema (Zod recommended), and core processing function.
3.  **Registration (`registration.ts`)**: Import logic, schema shape, `McpServer`, `ErrorHandler`. Use `server.tool(name, schemaShape, async handler => { ... })`. Wrap handler logic and registration in `ErrorHandler.tryCatch`.
4.  **Index (`index.ts`)**: Export registration function.
5.  **Server (`src/mcp-server/server.ts`)**: Import and call registration function within `createMcpServerInstance`.

### Adding a Resource

1.  **Directory**: `src/mcp-server/resources/yourResourceName/`
2.  **Logic (`logic.ts`)**: Define params type, query schema (if needed), and core processing function (takes `uri: URL`, `params`).
3.  **Registration (`registration.ts`)**: Import logic, schema, `McpServer`, `ResourceTemplate`, `ErrorHandler`. Define `ResourceTemplate`. Use `server.resource(regName, template, metadata, async handler => { ... })`. Wrap handler logic and registration in `ErrorHandler.tryCatch`.
4.  **Index (`index.ts`)**: Export registration function.
5.  **Server (`src/mcp-server/server.ts`)**: Import and call registration function within `createMcpServerInstance`.

## Key File Locations

- **Main Entry**: `src/index.ts` (Initializes server, handles startup/shutdown signals)
- **Server Setup**: `src/mcp-server/server.ts` (Handles transport logic (stdio/http), session management (http), registers tools/resources via `createMcpServerInstance`)
- **Configuration**: `src/config/index.ts` (Loads env vars, package info)
- **Global Types**: `src/types-global/`
- **Utilities**: `src/utils/` (Contains core helper modules)
- **Tools**: `src/mcp-server/tools/`
- **Resources**: `src/mcp-server/resources/`
- **Client Config**: `src/mcp-client/mcp-config.json` (Example, used for client connections)

Remember to keep this cheatsheet updated as the codebase evolves!
